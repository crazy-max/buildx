// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	command "github.com/docker/cli/cli/command"
	client "github.com/docker/docker/client"

	configfile "github.com/docker/cli/cli/config/configfile"

	docker "github.com/docker/cli/cli/context/docker"

	io "io"

	manifeststore "github.com/docker/cli/cli/manifest/store"

	mock "github.com/stretchr/testify/mock"

	notaryclient "github.com/theupdateframework/notary/client"

	registryclient "github.com/docker/cli/cli/registry/client"

	store "github.com/docker/cli/cli/context/store"

	streams "github.com/docker/cli/cli/streams"

	trust "github.com/docker/cli/cli/trust"
)

// DockerCli is an autogenerated mock type for the Cli type
type DockerCli struct {
	mock.Mock
}

type DockerCli_Expecter struct {
	mock *mock.Mock
}

func (_m *DockerCli) EXPECT() *DockerCli_Expecter {
	return &DockerCli_Expecter{mock: &_m.Mock}
}

// Apply provides a mock function with given fields: ops
func (_m *DockerCli) Apply(ops ...command.DockerCliOption) error {
	_va := make([]interface{}, len(ops))
	for _i := range ops {
		_va[_i] = ops[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(...command.DockerCliOption) error); ok {
		r0 = rf(ops...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DockerCli_Apply_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Apply'
type DockerCli_Apply_Call struct {
	*mock.Call
}

// Apply is a helper method to define mock.On call
//  - ops ...command.DockerCliOption
func (_e *DockerCli_Expecter) Apply(ops ...interface{}) *DockerCli_Apply_Call {
	return &DockerCli_Apply_Call{Call: _e.mock.On("Apply",
		append([]interface{}{}, ops...)...)}
}

func (_c *DockerCli_Apply_Call) Run(run func(ops ...command.DockerCliOption)) *DockerCli_Apply_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]command.DockerCliOption, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(command.DockerCliOption)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *DockerCli_Apply_Call) Return(_a0 error) *DockerCli_Apply_Call {
	_c.Call.Return(_a0)
	return _c
}

// BuildKitEnabled provides a mock function with given fields:
func (_m *DockerCli) BuildKitEnabled() (bool, error) {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DockerCli_BuildKitEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BuildKitEnabled'
type DockerCli_BuildKitEnabled_Call struct {
	*mock.Call
}

// BuildKitEnabled is a helper method to define mock.On call
func (_e *DockerCli_Expecter) BuildKitEnabled() *DockerCli_BuildKitEnabled_Call {
	return &DockerCli_BuildKitEnabled_Call{Call: _e.mock.On("BuildKitEnabled")}
}

func (_c *DockerCli_BuildKitEnabled_Call) Run(run func()) *DockerCli_BuildKitEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_BuildKitEnabled_Call) Return(_a0 bool, _a1 error) *DockerCli_BuildKitEnabled_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// Client provides a mock function with given fields:
func (_m *DockerCli) Client() client.APIClient {
	ret := _m.Called()

	var r0 client.APIClient
	if rf, ok := ret.Get(0).(func() client.APIClient); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(client.APIClient)
		}
	}

	return r0
}

// DockerCli_Client_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Client'
type DockerCli_Client_Call struct {
	*mock.Call
}

// Client is a helper method to define mock.On call
func (_e *DockerCli_Expecter) Client() *DockerCli_Client_Call {
	return &DockerCli_Client_Call{Call: _e.mock.On("Client")}
}

func (_c *DockerCli_Client_Call) Run(run func()) *DockerCli_Client_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_Client_Call) Return(_a0 client.APIClient) *DockerCli_Client_Call {
	_c.Call.Return(_a0)
	return _c
}

// ConfigFile provides a mock function with given fields:
func (_m *DockerCli) ConfigFile() *configfile.ConfigFile {
	ret := _m.Called()

	var r0 *configfile.ConfigFile
	if rf, ok := ret.Get(0).(func() *configfile.ConfigFile); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*configfile.ConfigFile)
		}
	}

	return r0
}

// DockerCli_ConfigFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigFile'
type DockerCli_ConfigFile_Call struct {
	*mock.Call
}

// ConfigFile is a helper method to define mock.On call
func (_e *DockerCli_Expecter) ConfigFile() *DockerCli_ConfigFile_Call {
	return &DockerCli_ConfigFile_Call{Call: _e.mock.On("ConfigFile")}
}

func (_c *DockerCli_ConfigFile_Call) Run(run func()) *DockerCli_ConfigFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_ConfigFile_Call) Return(_a0 *configfile.ConfigFile) *DockerCli_ConfigFile_Call {
	_c.Call.Return(_a0)
	return _c
}

// ContentTrustEnabled provides a mock function with given fields:
func (_m *DockerCli) ContentTrustEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// DockerCli_ContentTrustEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContentTrustEnabled'
type DockerCli_ContentTrustEnabled_Call struct {
	*mock.Call
}

// ContentTrustEnabled is a helper method to define mock.On call
func (_e *DockerCli_Expecter) ContentTrustEnabled() *DockerCli_ContentTrustEnabled_Call {
	return &DockerCli_ContentTrustEnabled_Call{Call: _e.mock.On("ContentTrustEnabled")}
}

func (_c *DockerCli_ContentTrustEnabled_Call) Run(run func()) *DockerCli_ContentTrustEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_ContentTrustEnabled_Call) Return(_a0 bool) *DockerCli_ContentTrustEnabled_Call {
	_c.Call.Return(_a0)
	return _c
}

// ContextStore provides a mock function with given fields:
func (_m *DockerCli) ContextStore() store.Store {
	ret := _m.Called()

	var r0 store.Store
	if rf, ok := ret.Get(0).(func() store.Store); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(store.Store)
		}
	}

	return r0
}

// DockerCli_ContextStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContextStore'
type DockerCli_ContextStore_Call struct {
	*mock.Call
}

// ContextStore is a helper method to define mock.On call
func (_e *DockerCli_Expecter) ContextStore() *DockerCli_ContextStore_Call {
	return &DockerCli_ContextStore_Call{Call: _e.mock.On("ContextStore")}
}

func (_c *DockerCli_ContextStore_Call) Run(run func()) *DockerCli_ContextStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_ContextStore_Call) Return(_a0 store.Store) *DockerCli_ContextStore_Call {
	_c.Call.Return(_a0)
	return _c
}

// CurrentContext provides a mock function with given fields:
func (_m *DockerCli) CurrentContext() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// DockerCli_CurrentContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CurrentContext'
type DockerCli_CurrentContext_Call struct {
	*mock.Call
}

// CurrentContext is a helper method to define mock.On call
func (_e *DockerCli_Expecter) CurrentContext() *DockerCli_CurrentContext_Call {
	return &DockerCli_CurrentContext_Call{Call: _e.mock.On("CurrentContext")}
}

func (_c *DockerCli_CurrentContext_Call) Run(run func()) *DockerCli_CurrentContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_CurrentContext_Call) Return(_a0 string) *DockerCli_CurrentContext_Call {
	_c.Call.Return(_a0)
	return _c
}

// DefaultVersion provides a mock function with given fields:
func (_m *DockerCli) DefaultVersion() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// DockerCli_DefaultVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DefaultVersion'
type DockerCli_DefaultVersion_Call struct {
	*mock.Call
}

// DefaultVersion is a helper method to define mock.On call
func (_e *DockerCli_Expecter) DefaultVersion() *DockerCli_DefaultVersion_Call {
	return &DockerCli_DefaultVersion_Call{Call: _e.mock.On("DefaultVersion")}
}

func (_c *DockerCli_DefaultVersion_Call) Run(run func()) *DockerCli_DefaultVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_DefaultVersion_Call) Return(_a0 string) *DockerCli_DefaultVersion_Call {
	_c.Call.Return(_a0)
	return _c
}

// DockerEndpoint provides a mock function with given fields:
func (_m *DockerCli) DockerEndpoint() docker.Endpoint {
	ret := _m.Called()

	var r0 docker.Endpoint
	if rf, ok := ret.Get(0).(func() docker.Endpoint); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(docker.Endpoint)
	}

	return r0
}

// DockerCli_DockerEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DockerEndpoint'
type DockerCli_DockerEndpoint_Call struct {
	*mock.Call
}

// DockerEndpoint is a helper method to define mock.On call
func (_e *DockerCli_Expecter) DockerEndpoint() *DockerCli_DockerEndpoint_Call {
	return &DockerCli_DockerEndpoint_Call{Call: _e.mock.On("DockerEndpoint")}
}

func (_c *DockerCli_DockerEndpoint_Call) Run(run func()) *DockerCli_DockerEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_DockerEndpoint_Call) Return(_a0 docker.Endpoint) *DockerCli_DockerEndpoint_Call {
	_c.Call.Return(_a0)
	return _c
}

// Err provides a mock function with given fields:
func (_m *DockerCli) Err() io.Writer {
	ret := _m.Called()

	var r0 io.Writer
	if rf, ok := ret.Get(0).(func() io.Writer); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.Writer)
		}
	}

	return r0
}

// DockerCli_Err_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Err'
type DockerCli_Err_Call struct {
	*mock.Call
}

// Err is a helper method to define mock.On call
func (_e *DockerCli_Expecter) Err() *DockerCli_Err_Call {
	return &DockerCli_Err_Call{Call: _e.mock.On("Err")}
}

func (_c *DockerCli_Err_Call) Run(run func()) *DockerCli_Err_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_Err_Call) Return(_a0 io.Writer) *DockerCli_Err_Call {
	_c.Call.Return(_a0)
	return _c
}

// In provides a mock function with given fields:
func (_m *DockerCli) In() *streams.In {
	ret := _m.Called()

	var r0 *streams.In
	if rf, ok := ret.Get(0).(func() *streams.In); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*streams.In)
		}
	}

	return r0
}

// DockerCli_In_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'In'
type DockerCli_In_Call struct {
	*mock.Call
}

// In is a helper method to define mock.On call
func (_e *DockerCli_Expecter) In() *DockerCli_In_Call {
	return &DockerCli_In_Call{Call: _e.mock.On("In")}
}

func (_c *DockerCli_In_Call) Run(run func()) *DockerCli_In_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_In_Call) Return(_a0 *streams.In) *DockerCli_In_Call {
	_c.Call.Return(_a0)
	return _c
}

// ManifestStore provides a mock function with given fields:
func (_m *DockerCli) ManifestStore() manifeststore.Store {
	ret := _m.Called()

	var r0 manifeststore.Store
	if rf, ok := ret.Get(0).(func() manifeststore.Store); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(manifeststore.Store)
		}
	}

	return r0
}

// DockerCli_ManifestStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ManifestStore'
type DockerCli_ManifestStore_Call struct {
	*mock.Call
}

// ManifestStore is a helper method to define mock.On call
func (_e *DockerCli_Expecter) ManifestStore() *DockerCli_ManifestStore_Call {
	return &DockerCli_ManifestStore_Call{Call: _e.mock.On("ManifestStore")}
}

func (_c *DockerCli_ManifestStore_Call) Run(run func()) *DockerCli_ManifestStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_ManifestStore_Call) Return(_a0 manifeststore.Store) *DockerCli_ManifestStore_Call {
	_c.Call.Return(_a0)
	return _c
}

// NotaryClient provides a mock function with given fields: imgRefAndAuth, actions
func (_m *DockerCli) NotaryClient(imgRefAndAuth trust.ImageRefAndAuth, actions []string) (notaryclient.Repository, error) {
	ret := _m.Called(imgRefAndAuth, actions)

	var r0 notaryclient.Repository
	if rf, ok := ret.Get(0).(func(trust.ImageRefAndAuth, []string) notaryclient.Repository); ok {
		r0 = rf(imgRefAndAuth, actions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(notaryclient.Repository)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(trust.ImageRefAndAuth, []string) error); ok {
		r1 = rf(imgRefAndAuth, actions)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DockerCli_NotaryClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotaryClient'
type DockerCli_NotaryClient_Call struct {
	*mock.Call
}

// NotaryClient is a helper method to define mock.On call
//  - imgRefAndAuth trust.ImageRefAndAuth
//  - actions []string
func (_e *DockerCli_Expecter) NotaryClient(imgRefAndAuth interface{}, actions interface{}) *DockerCli_NotaryClient_Call {
	return &DockerCli_NotaryClient_Call{Call: _e.mock.On("NotaryClient", imgRefAndAuth, actions)}
}

func (_c *DockerCli_NotaryClient_Call) Run(run func(imgRefAndAuth trust.ImageRefAndAuth, actions []string)) *DockerCli_NotaryClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(trust.ImageRefAndAuth), args[1].([]string))
	})
	return _c
}

func (_c *DockerCli_NotaryClient_Call) Return(_a0 notaryclient.Repository, _a1 error) *DockerCli_NotaryClient_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// Out provides a mock function with given fields:
func (_m *DockerCli) Out() *streams.Out {
	ret := _m.Called()

	var r0 *streams.Out
	if rf, ok := ret.Get(0).(func() *streams.Out); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*streams.Out)
		}
	}

	return r0
}

// DockerCli_Out_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Out'
type DockerCli_Out_Call struct {
	*mock.Call
}

// Out is a helper method to define mock.On call
func (_e *DockerCli_Expecter) Out() *DockerCli_Out_Call {
	return &DockerCli_Out_Call{Call: _e.mock.On("Out")}
}

func (_c *DockerCli_Out_Call) Run(run func()) *DockerCli_Out_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_Out_Call) Return(_a0 *streams.Out) *DockerCli_Out_Call {
	_c.Call.Return(_a0)
	return _c
}

// RegistryClient provides a mock function with given fields: _a0
func (_m *DockerCli) RegistryClient(_a0 bool) registryclient.RegistryClient {
	ret := _m.Called(_a0)

	var r0 registryclient.RegistryClient
	if rf, ok := ret.Get(0).(func(bool) registryclient.RegistryClient); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(registryclient.RegistryClient)
		}
	}

	return r0
}

// DockerCli_RegistryClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegistryClient'
type DockerCli_RegistryClient_Call struct {
	*mock.Call
}

// RegistryClient is a helper method to define mock.On call
//  - _a0 bool
func (_e *DockerCli_Expecter) RegistryClient(_a0 interface{}) *DockerCli_RegistryClient_Call {
	return &DockerCli_RegistryClient_Call{Call: _e.mock.On("RegistryClient", _a0)}
}

func (_c *DockerCli_RegistryClient_Call) Run(run func(_a0 bool)) *DockerCli_RegistryClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *DockerCli_RegistryClient_Call) Return(_a0 registryclient.RegistryClient) *DockerCli_RegistryClient_Call {
	_c.Call.Return(_a0)
	return _c
}

// ServerInfo provides a mock function with given fields:
func (_m *DockerCli) ServerInfo() command.ServerInfo {
	ret := _m.Called()

	var r0 command.ServerInfo
	if rf, ok := ret.Get(0).(func() command.ServerInfo); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(command.ServerInfo)
	}

	return r0
}

// DockerCli_ServerInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ServerInfo'
type DockerCli_ServerInfo_Call struct {
	*mock.Call
}

// ServerInfo is a helper method to define mock.On call
func (_e *DockerCli_Expecter) ServerInfo() *DockerCli_ServerInfo_Call {
	return &DockerCli_ServerInfo_Call{Call: _e.mock.On("ServerInfo")}
}

func (_c *DockerCli_ServerInfo_Call) Run(run func()) *DockerCli_ServerInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_ServerInfo_Call) Return(_a0 command.ServerInfo) *DockerCli_ServerInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

// SetIn provides a mock function with given fields: in
func (_m *DockerCli) SetIn(in *streams.In) {
	_m.Called(in)
}

// DockerCli_SetIn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetIn'
type DockerCli_SetIn_Call struct {
	*mock.Call
}

// SetIn is a helper method to define mock.On call
//  - in *streams.In
func (_e *DockerCli_Expecter) SetIn(in interface{}) *DockerCli_SetIn_Call {
	return &DockerCli_SetIn_Call{Call: _e.mock.On("SetIn", in)}
}

func (_c *DockerCli_SetIn_Call) Run(run func(in *streams.In)) *DockerCli_SetIn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*streams.In))
	})
	return _c
}

func (_c *DockerCli_SetIn_Call) Return() *DockerCli_SetIn_Call {
	_c.Call.Return()
	return _c
}

type mockConstructorTestingTNewDockerCli interface {
	mock.TestingT
	Cleanup(func())
}

// NewDockerCli creates a new instance of DockerCli. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewDockerCli(t mockConstructorTestingTNewDockerCli) *DockerCli {
	mock := &DockerCli{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
